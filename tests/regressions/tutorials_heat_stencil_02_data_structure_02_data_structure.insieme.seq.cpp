/**
 * ------------------------ Auto-generated Code ------------------------ 
 *           This code was generated by the Insieme Compiler 
 * --------------------------------------------------------------------- 
 */
#include <algorithm>
#include <alloca.h>
#include <allscale/api/user/data/static_grid.h>
#include <allscale/runtime.hpp>
#include <allscale/utils/vector.h>
#include <iostream>
#include <stdint.h>

#ifdef __cplusplus
#define INS_INIT(...) __VA_ARGS__
#else
#define INS_INIT(...) (__VA_ARGS__)
#endif
#ifdef __cplusplus
#include <new>
#define INS_INPLACE_INIT(Loc,Type) new(Loc) Type
#else
#define INS_INPLACE_INIT(Loc,Type) *(Loc) = (Type)
#endif
#ifdef __cplusplus
				/** Workaround for libstdc++/libc bug.
				 *  There's an inconsistency between libstdc++ and libc regarding whether
				 *  ::gets is declared or not, which is only evident when using certain
				 *  compilers and language settings
				 *  (tested positively with clang 3.9 --std=c++14 and libc 2.17).
				 */
				#include <initializer_list>  // force libstdc++ to include its config
				#undef _GLIBCXX_HAVE_GETS    // correct broken config
#endif

/* ------- Program Code --------- */

struct __wi_main_variant_1;
typedef struct __wi_main_variant_1 __wi_main_variant_1;

struct __wi_main_variant_0;
typedef struct __wi_main_variant_0 __wi_main_variant_0;

struct __wi_main_name {
    static const char* name() { return "__wi_main"; }
};

using __wi_main_work = allscale::work_item_description<int32_t, __wi_main_name, allscale::no_serialization, __wi_main_variant_0, __wi_main_variant_1 >;

/* ------- Function Definitions --------- */
int32_t main() {
    return allscale::runtime::main_wrapper<__wi_main_work >();
}

ALLSCALE_REGISTER_TREETURE_TYPE(int32_t)
struct allscale_type_24;
typedef struct allscale_type_24 allscale_type_24;

struct allscale_type_24 {
    char data[3];;
};

struct allscale_type_25;
typedef struct allscale_type_25 allscale_type_25;

struct allscale_type_25 {
    char data[12];;
};

/* ------- Function Definitions --------- */
int32_t IMP_main() {
    const int32_t var_0 = 200;
    const int32_t var_1 = 100;
    const double var_2 = 1.0E-3;
    allscale::api::user::data::StaticGrid<double, 200, 200 > var_3;
    allscale::api::user::data::StaticGrid<double, 200, 200 > var_4;
    allscale::api::user::data::StaticGrid<double, 200, 200 >& var_5 = var_3;
    {
        int32_t var_6 = 0;
        while (var_6 < var_0) {
            {
                int32_t var_7 = 0;
                while (var_7 < var_0) {
                    {
                        var_5.operator[](allscale::utils::Vector<int64_t, 2 >(var_6, var_7)) = (double)0;
                        if (var_6 == var_0 / 2 && var_7 == var_0 / 2) {
                            var_5.operator[](allscale::utils::Vector<int64_t, 2 >(var_6, var_7)) = (double)100;
                        };
                    };
                    var_7++;
                };
            };
            var_6++;
        };
    };
    {
        for (int32_t var_8 = 0; var_8 < var_1; ++var_8) {
            {
                allscale::api::user::data::StaticGrid<double, 200, 200 >& var_9 = var_3;
                allscale::api::user::data::StaticGrid<double, 200, 200 >& var_10 = var_4;
                {
                    int32_t var_11 = 1;
                    while (var_11 < var_0 - 1) {
                        {
                            int32_t var_12 = 1;
                            while (var_12 < var_0 - 1) {
                                var_10.operator[](allscale::utils::Vector<int64_t, 2 >(var_11, var_12)) = var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11, var_12)) + var_2 * (var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11 - 1, var_12)) + var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11 + 1, var_12)) + var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11, var_12 - 1)) + var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11, var_12 + 1)) + (double)-4 * var_9.operator[](allscale::utils::Vector<int64_t, 2 >(var_11, var_12)));
                                var_12++;
                            };
                        };
                        var_11++;
                    };
                };
                if (var_8 % (var_1 / 10) == 0) {
                    std::operator<<(std::operator<<(std::cout, "t=").operator<<(var_8), " - center: ").operator<<(var_10.operator[](allscale::utils::Vector<int64_t, 2 >(var_0 / 2, var_0 / 2))).operator<<(&std::endl);
                };
                std::swap(var_3, var_4);
            };
        };
    };
    std::operator<<(std::operator<<(std::cout, "t=").operator<<(var_1), " - center: ").operator<<(var_5.operator[](allscale::utils::Vector<int64_t, 2 >(var_0 / 2, var_0 / 2))).operator<<(&std::endl);
    return var_5.operator[](allscale::utils::Vector<int64_t, 2 >(var_0 / 2, var_0 / 2)) < (double)69?0:1;
}
/* ------- Function Definitions --------- */
allscale::treeture<int32_t > allscale_fun_1(hpx::util::tuple< > const& var_0) {
    return allscale::treeture<int32_t >(IMP_main());
}
struct __wi_main_variant_1 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple< > const& var_0);
    static constexpr bool valid = true;
};

allscale::treeture<int32_t > __wi_main_variant_1::execute(hpx::util::tuple< > const& var_0) {
    return allscale_fun_1(var_0);
}
struct __wi_main_variant_0 {
    static allscale::treeture<int32_t > execute(hpx::util::tuple< > const& var_0);
    static constexpr bool valid = true;
};

allscale::treeture<int32_t > __wi_main_variant_0::execute(hpx::util::tuple< > const& var_0) {
    return allscale_fun_1(var_0);
}

