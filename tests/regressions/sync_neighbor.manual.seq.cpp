/**
 * ------------------------ Auto-generated Code ------------------------
 *           This code was generated by the Insieme Compiler
 * ---------------------------------------------------------------------
 */
#include <hpx/util/lightweight_test.hpp>
#include <algorithm>
#include <alloca.h>
#include <allscale/runtime.hpp>
#include <allscale/utils/assert.h>
#include <cassert>
#include <functional>
#include <iostream>
#include <stdbool.h>
#include <stdint.h>
#include <utility>

#ifdef __cplusplus
#define INS_INIT(...) __VA_ARGS__
#else
#define INS_INIT(...) (__VA_ARGS__)
#endif
#ifdef __cplusplus
#include <new>
#define INS_INPLACE_INIT(Loc,Type) new(Loc) Type
#else
#define INS_INPLACE_INIT(Loc,Type) *(Loc) = (Type)
#endif
#ifdef __cplusplus
				/** Workaround for libstdc++/libc bug.
				 *  There's an inconsistency between libstdc++ and libc regarding whether
				 *  ::gets is declared or not, which is only evident when using certain
				 *  compilers and language settings
				 *  (tested positively with clang 3.9 --std=c++14 and libc 2.17).
				 */
				#include <initializer_list>  // force libstdc++ to include its config
				#undef _GLIBCXX_HAVE_GETS    // correct broken config
#endif

ALLSCALE_REGISTER_TREETURE_TYPE(int32_t);

struct range_int {
    int32_t _begin;
    int32_t _end;;
    range_int();
    range_int(int32_t const& p2, int32_t const& p3);
    bool empty() const;
    uint64_t size() const;
    int32_t const& begin() const;
    bool covers(range_int const& p2) const;
    int32_t const& end() const;
    template <typename F>
    void for_each(F const& p2) const
    {
        for (int32_t var_3 = _begin; var_3 < _end; ++var_3) {
            p2(var_3);
        };
    }
    range_int grow(range_int const& p2, int32_t p3) const;
    range_int shrink(int32_t p2) const;
    std::pair<range_int, range_int > split() const;
};

struct iteration_reference_int {
    range_int _range;
    allscale::treeture<void > handle;
    iteration_reference_int()
    {}

    iteration_reference_int(range_int const& p2, allscale::treeture<void > const& p3);
    allscale::treeture<void > const& get_handle() const;
    iteration_reference_int get_left() const;
    range_int const& get_range() const;
    iteration_reference_int get_right() const;
    void wait() const;
};

struct loop_dependency
{
};

struct sub_dependency_int;

struct dependency_int : public loop_dependency {
    std::array<iteration_reference_int, 3 > deps;
    uint64_t size;
    dependency_int(iteration_reference_int const& p2)
      : size(1)
    {
        deps[0] = p2;
    }

    explicit dependency_int(std::array<iteration_reference_int, 3 >&& p2);
    sub_dependency_int split(range_int const& p2, range_int const& p3) const;
    allscale::runtime::dependencies to_core_dependencies() const
    {
        if (size == 1u)
        {
            return allscale::runtime::after(deps[0].handle);
        }
        else
        {
            HPX_ASSERT(size == 3);
            return allscale::runtime::after(
                deps[0].handle,
                deps[1].handle,
                deps[2].handle
            );
        }
    }
};

struct sub_dependency_int {
    dependency_int left;
    dependency_int right;;
};

struct pfor_928_3 {
    range_int range;
    dependency_int dependencies;;
};


/* ------- Program Code --------- */


struct range_int;

struct neighbor_dot_24_23;


struct neighbor_dot_24_23 {
    std::vector<int32_t, std::allocator<int32_t > >& capture_0;
    std::vector<int32_t, std::allocator<int32_t > >& capture_1;;
    neighbor_dot_24_23(neighbor_dot_24_23 const& p2) = default;
    neighbor_dot_24_23(neighbor_dot_24_23&& p2) = default;
    neighbor_dot_24_23(std::vector<int32_t, std::allocator<int32_t > >& p2, std::vector<int32_t, std::allocator<int32_t > >& p3);
    ~neighbor_dot_24_23() = default;
    neighbor_dot_24_23& operator=(neighbor_dot_24_23 const& p2) = default;
    neighbor_dot_24_23& operator=(neighbor_dot_24_23&& p2) = default;
    void operator()(int32_t p2) const;
};

struct sub_no_dependencies;

struct no_dependencies : public loop_dependency {
    sub_no_dependencies split() const;
};

struct sub_no_dependencies {
    no_dependencies left;
    no_dependencies right;;
};

sub_no_dependencies no_dependencies::split() const {
    return sub_no_dependencies();
}

struct __wi_allscale_wi_1_name;
struct __wi_allscale_wi_1_variant_0;
struct __wi_allscale_wi_1_variant_1;
struct __wi_allscale_wi_1_can_split;
using __wi_allscale_wi_1_work = allscale::work_item_description<void, __wi_allscale_wi_1_name, allscale::no_serialization, __wi_allscale_wi_1_variant_0, __wi_allscale_wi_1_variant_1, __wi_allscale_wi_1_can_split >;

struct __wi_allscale_wi_1_name {
    static const char* name() { return "__wi_allscale_wi_1"; }
};

struct __wi_allscale_wi_1_variant_0 {
    template <typename Closure>
    static allscale::treeture<void > execute(Closure const& var_0)
    {
        std::pair<range_int, range_int > var_1 = hpx::util::get<0 >(var_0).split();
        range_int& var_2 = var_1.first;
        range_int& var_3 = var_1.second;

        return allscale::runtime::treeture_parallel(
            allscale::runtime::after(),
            allscale::spawn_with_dependencies<__wi_allscale_wi_1_work >(
                allscale::runtime::after(),
                var_2, hpx::util::get<1 >(var_0)
            ),
            allscale::spawn_with_dependencies<__wi_allscale_wi_1_work >(
                allscale::runtime::after(),
                var_3, hpx::util::get<1 >(var_0)
            )
        );
    }
    static constexpr bool valid = true;
};

struct __wi_allscale_wi_1_variant_1 {
    template <typename Closure>
    static hpx::util::unused_type execute(Closure const& var_0)
    {
        hpx::util::get<0 >(var_0).for_each(hpx::util::get<1>(var_0));
        return hpx::util::unused;
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
struct __wi_allscale_wi_1_can_split {
    template <typename Closure>
    static bool call(Closure const& var_0)
    {
        return !(hpx::util::get<0 >(var_0).size() <= 1u);
    }
};

using __wi_allscale_wi_1_work = allscale::work_item_description<void, __wi_allscale_wi_1_name, allscale::no_serialization, __wi_allscale_wi_1_variant_0, __wi_allscale_wi_1_variant_1, __wi_allscale_wi_1_can_split >;

/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */

struct __wi_allscale_wi_2_name;
struct __wi_allscale_wi_2_variant_0;
struct __wi_allscale_wi_2_variant_1;
struct __wi_allscale_wi_2_can_split;
using __wi_allscale_wi_2_work = allscale::work_item_description<void, __wi_allscale_wi_2_name, allscale::no_serialization, __wi_allscale_wi_2_variant_0, __wi_allscale_wi_2_variant_1, __wi_allscale_wi_2_can_split >;

struct __wi_allscale_wi_2_name {
    static const char* name() { return "__wi_allscale_wi_2"; }
};

struct __wi_allscale_wi_2_variant_0 {
    template <typename Closure>
    static hpx::future<void > execute(Closure const& var_0)
    {
        std::pair<range_int, range_int > var_1 = hpx::util::get<0 >(var_0).range.split();
        range_int& var_2 = var_1.first;
        range_int& var_3 = var_1.second;
        sub_dependency_int var_4 = hpx::util::get<0 >(var_0).dependencies.split(var_2, var_3);

        auto t1 = allscale::spawn_with_dependencies<__wi_allscale_wi_2_work >(
                var_4.left.to_core_dependencies(),
                pfor_928_3{var_2, var_4.left},
                hpx::util::get<1 >(var_0)
            );
        auto t2 = allscale::spawn_with_dependencies<__wi_allscale_wi_2_work >(
                var_4.right.to_core_dependencies(),
                pfor_928_3{var_3, var_4.right},
                hpx::util::get<1 >(var_0));

        return hpx::when_all(t1.get_future(), t2.get_future());
    }
    static constexpr bool valid = true;
};

struct __wi_allscale_wi_2_variant_1 {
    template <typename Closure>
    static hpx::util::unused_type execute(Closure const& var_0)
    {
        hpx::util::get<0 >(var_0).range.for_each(hpx::util::get<1>(var_0));
        return hpx::util::unused;
    }
    static constexpr bool valid = true;
};

struct __wi_allscale_wi_2_can_split {
    template <typename Closure>
    static bool call(Closure const& var_0)
    {
        return !(hpx::util::get<0 >(var_0).range.size() <= (uint64_t)1);
    }
};
struct __wi_allscale_wi_3_name;
struct __wi_allscale_wi_3_variant_0;
struct __wi_allscale_wi_3_variant_1;
struct __wi_allscale_wi_3_can_split;

using __wi_allscale_wi_3_work = allscale::work_item_description<void, __wi_allscale_wi_3_name, allscale::no_serialization, __wi_allscale_wi_3_variant_0, __wi_allscale_wi_3_variant_1, __wi_allscale_wi_3_can_split >;

/* ------- Function Definitions --------- */
struct __wi_allscale_wi_3_name {
    static const char* name() { return "__wi_allscale_wi_3"; }
};

struct __wi_allscale_wi_3_variant_0 {
    template <typename Closure>
    static hpx::future<void > execute(Closure const& var_0)
    {
        std::pair<range_int, range_int > var_1 = hpx::util::get<0 >(var_0).range.split();
        range_int& var_2 = var_1.first;
        range_int& var_3 = var_1.second;
        sub_dependency_int var_4 = hpx::util::get<0 >(var_0).dependencies.split(var_2, var_3);
        auto t1 = allscale::spawn_with_dependencies<__wi_allscale_wi_3_work >(
                var_4.left.to_core_dependencies(),
                pfor_928_3{var_2, var_4.left},
                hpx::util::get<1 >(var_0)
            );
        auto t2 = allscale::spawn_with_dependencies<__wi_allscale_wi_3_work >(
                var_4.right.to_core_dependencies(),
                pfor_928_3{var_3, var_4.right},
                hpx::util::get<1 >(var_0)
            );

        return hpx::when_all(t1.get_future(), t2.get_future());
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
struct __wi_allscale_wi_3_can_split {
    template <typename Closure>
    static bool call(Closure const& var_0)
    {
        return !(hpx::util::get<0 >(var_0).range.size() <= 1u);
    }
};

struct __wi_allscale_wi_3_variant_1 {
    template <typename Closure>
    static hpx::util::unused_type execute(Closure const& var_0)
    {
        hpx::util::get<0 >(var_0).range.for_each(hpx::util::get<1 >(var_0));
        return hpx::util::unused;
    }
    static constexpr bool valid = true;
};

/* ------- Function Definitions --------- */
allscale::treeture<void > allscale_fun_315(allscale::runtime::dependencies const& var_0, hpx::util::tuple<pfor_928_3, neighbor_dot_24_23> const& var_1) {
    return allscale::spawn_with_dependencies<__wi_allscale_wi_3_work >(var_0, hpx::util::get<0 >(var_1), hpx::util::get<1 >(var_1));
}
/* ------- Function Definitions --------- */
iteration_reference_int allscale_fun_313(range_int const& var_0, neighbor_dot_24_23 const& var_1, dependency_int const& var_2) {
    return {var_0, allscale::runtime::make_prec_operation<pfor_928_3, void >(hpx::util::make_tuple(var_1), &allscale_fun_315)(var_2.to_core_dependencies(), pfor_928_3{var_0, var_2})};
}
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
void neighbor_dot_24_23::operator()(int32_t var_1) const {
    if (var_1 != 0)
    {
        HPX_TEST_EQ(capture_0[var_1 - 1], 2);
    }
    if (var_1 != 10000000 - 1)
    {
        HPX_TEST_EQ(capture_0[var_1 + 1], 2);
    }
    HPX_TEST_EQ(capture_0[var_1], 2);
    capture_1[var_1] = 3;
}
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
neighbor_dot_24_23::neighbor_dot_24_23(std::vector<int32_t, std::allocator<int32_t > >& var_1, std::vector<int32_t, std::allocator<int32_t > >& var_2) : capture_0(var_1), capture_1(var_2) { }
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
uint64_t range_int::size() const {
    return (uint64_t)(_begin < _end ? _end - _begin : 0);
}
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
int32_t const& range_int::end() const {
    return _end;
}
/* ------- Function Definitions --------- */
int32_t const& range_int::begin() const {
    return _begin;
}
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
bool range_int::covers(range_int const& var_1) const {
    return var_1._begin >= var_1._end || _begin <= var_1._begin && var_1._end <= _end;
}
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
bool range_int::empty() const {
    return size() == (uint64_t)0;
}
/* ------- Function Definitions --------- */
range_int::range_int(int32_t const& var_1, int32_t const& var_2) : _begin(var_1), _end(var_2) {
    if (empty()) {
        _end = _begin;
    };
}
/* ------- Function Definitions --------- */
range_int::range_int() : _begin(0), _end(0) { }
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
std::pair<range_int, range_int > range_int::split() const {
    int32_t var_3 = _begin + (_end - _begin) / 2;
    return std::make_pair(range_int(_begin, var_3), range_int(var_3, _end));
}
range_int range_int::grow(range_int const& var_1, int32_t var_2) const {
    return range_int(std::max(var_1.begin(), _begin - var_2), std::min(var_1.end(), _end + var_2));
}
range_int range_int::shrink(int32_t var_1) const {
    return grow(*this, -var_1);
}
range_int const& iteration_reference_int::get_range() const {
    return _range;
}
void iteration_reference_int::wait() const {
    if (handle.valid()) {
        handle.wait();
    };
}
iteration_reference_int iteration_reference_int::get_right() const {
    int32_t var_3 = _range._begin + (_range._end - +_range._begin) / 2;
    return {range_int(var_3, _range._end), handle.get_right_child()};
}
allscale::treeture<void > const& iteration_reference_int::get_handle() const {
    return handle;
}
iteration_reference_int iteration_reference_int::get_left() const {
    int32_t var_3 = _range._begin + (_range._end - +_range._begin) / 2;
    return {range_int(_range._begin, var_3), handle.get_left_child()};
}
iteration_reference_int::iteration_reference_int(range_int const& var_1, allscale::treeture<void > const& var_2) : _range(var_1), handle(var_2) { }

dependency_int::dependency_int(std::array<iteration_reference_int, 3 >&& var_1) : loop_dependency(), deps(std::move(var_1)), size((uint64_t)3) { }

sub_dependency_int dependency_int::split(range_int const& var_1, range_int const& var_2) const {
    if (size == 1u) {

        iteration_reference_int const& var_3 = deps[0];
        iteration_reference_int const& var_4 = var_3.get_left();
        iteration_reference_int const& var_5 = var_3.get_right();
        iteration_reference_int var_6(
            range_int(var_4.get_range().end(), var_4.get_range().end()),
            allscale::make_ready_treeture()//var_4.get_handle()
        );
        iteration_reference_int var_7(
            range_int(var_5.get_range().begin(), var_5.get_range().begin()),
            allscale::make_ready_treeture()//var_4.get_handle()
        );
        return {
            dependency_int(
                std::array<iteration_reference_int, 3 >{{
                    var_6, var_4, var_5
                }}
            ),
            dependency_int(
                std::array<iteration_reference_int, 3 >{{
                    var_4, var_5, var_7
                }}
            )
        };
    };
    iteration_reference_int var_8 = deps[0].get_right();
    iteration_reference_int var_9 = deps[1].get_left();
    iteration_reference_int var_10 = deps[1].get_right();
    iteration_reference_int var_11 = deps[2].get_left();
    range_int var_12(deps[0].get_range().begin(), deps[2].get_range().end());
    range_int var_13(var_8.get_range().begin(), var_10.get_range().end());
    range_int var_14(var_9.get_range().begin(), var_11.get_range().end());
    return {
        var_13.covers(var_1.grow(var_12, 1)) ?
            dependency_int(std::array<iteration_reference_int, 3 >{{var_8, var_9, var_10}}) :
            *this,
        var_14.covers(var_2.grow(var_12, 1)) ?
            dependency_int(std::array<iteration_reference_int, 3 >{{var_9, var_10, var_11}}) :
            *this
    };
}

struct __wi_main_name {
    static const char* name() { return "__wi_main"; }
};

/* ------- Function Definitions --------- */
/* ------- Function Definitions --------- */
struct __wi_main_variant_1 {
    struct fun1 {
        std::vector<int32_t>& capture_0;;
        fun1(std::vector<int32_t>& p2) : capture_0(p2) { }
        void operator()(int32_t p2) const
        {
            capture_0[p2] = 1;
        }
    };
    struct fun2 {
        std::vector<int32_t>& capture_0;
        std::vector<int32_t>& capture_1;;
        fun2(std::vector<int32_t>& p2, std::vector<int32_t>& p3)
          : capture_0(p2), capture_1(p3) { }
        void operator()(int32_t var_1) const
        {
            if (var_1 != 0)
            {
                HPX_TEST_EQ(capture_0[var_1 - 1], 1);
            }
            if (var_1 != 10000000 - 1)
            {
                HPX_TEST_EQ(capture_0[var_1 + 1], 1);
            }
            HPX_TEST_EQ(capture_0[var_1], 1);
            capture_1[var_1] = 2;
        }
    };

    template <typename Work, typename T, typename F>
    static allscale::treeture<void > spawn(allscale::runtime::dependencies const& var_0, hpx::util::tuple<T, F> const& var_1) {
        return allscale::spawn_with_dependencies<Work>(var_0, hpx::util::get<0 >(var_1), hpx::util::get<1>(var_1));
    }

    static allscale::treeture<int32_t > execute(hpx::util::tuple< > const&)
    {
        const int32_t var_0 = 10000000;
        std::vector<int32_t> var_1(var_0);
        std::vector<int32_t> var_2(var_0);

        iteration_reference_int var_3 = {
            range_int(0, var_0),
            allscale::runtime::make_prec_operation<range_int, void >(
                hpx::util::make_tuple(fun1{var_1}),
                &__wi_main_variant_1::spawn<__wi_allscale_wi_1_work, range_int, fun1>
            )(range_int(0, var_0))
        };

        dependency_int dep3(var_3);
        iteration_reference_int var_4 ={
            range_int(0, var_0),
            allscale::runtime::make_prec_operation<pfor_928_3, void >(
                hpx::util::make_tuple(fun2{var_1, var_2}),
                &__wi_main_variant_1::spawn<__wi_allscale_wi_2_work, pfor_928_3, fun2>
            )(dep3.to_core_dependencies(), pfor_928_3{range_int(0, var_0), dep3})
        };

        iteration_reference_int var_5 = allscale_fun_313(range_int(0, var_0), neighbor_dot_24_23{var_2, var_1}, dependency_int(var_4));

        var_5.wait();
        {
            int32_t var_6 = 0;
            while (var_6 < var_0) {
                HPX_TEST_EQ(var_1[var_6], 3);
                HPX_TEST_EQ(var_2[var_6], 2);
                var_6++;
            };
        };
        return allscale::treeture<int32_t >(0);
    }
    static constexpr bool valid = true;
};


using __wi_main_work = allscale::work_item_description<int32_t, __wi_main_name, allscale::no_serialization, allscale::no_split<int32_t>, __wi_main_variant_1>;

/* ------- Function Definitions --------- */
int32_t main() {
    HPX_TEST_EQ(allscale::runtime::main_wrapper<__wi_main_work >(), 0);

    return hpx::util::report_errors();
}
